apiVersion: v1
kind: Template
metadata:
  name: "${NAME}"
  annotations:
    description: "NR SPAR Fluent-bit Config Map"
    tags: "nr-spar-backend,fluent-bit"
labels:
  app: "${NAME}-${ZONE}"
objects:
  - apiVersion: v1
    kind: ConfigMap
    metadata:
      name: ${NAME}-${ZONE}-fluent-bit-config
      namespace: ${NAMESPACE}
    data:
      filters.conf: >

        [FILTER]
          Name modify
          Match *
          Add agent.type fluentbit
          Add agent.version ${FLUENT_VERSION}
          Add agent.name ${AGENT_NAME}
          Add ecs.version 8.4
          Rename event_sequence event.sequence
          Rename log_file_path log.file.path

        [FILTER]
            Name lua
            Match spar
            script ${FLUENT_CONF_HOME}/timestamp.lua
            time_as_table True
            call append_event_created


        # There is a bug when resolving environment variables with spaces in the value :(

        # So, we have to use Lua script for now

        # Reference: https://github.com/fluent/fluent-bit/issues/1225

        [FILTER]
            Name lua
            Match *
            script ${FLUENT_CONF_HOME}/host_metadata.lua
            time_as_table True
            call add_host_metadata
      fluent-bit.conf: |
        [SERVICE]
            Log_Level       info
            Parsers_File    parsers.conf

        @INCLUDE spar/input/inputs.conf

        @INCLUDE spar/filter/filters.conf


        @INCLUDE filters.conf
        @INCLUDE outputs.conf
      generic_json_parsers.conf: |
        [PARSER]
            Name        generic_json
            Format      json
      host_metadata.lua: |
        -- Space delimited values to array
        function sdv2array(s)
            delimiter = "%S+"
            result = {};
            for match in string.gmatch(s, delimiter) do
                table.insert(result, match);
            end
            return result;
        end

        function isempty(s)
            return s == nil or s == ''
        end

        function copy(obj)
            if type(obj) ~= 'table' then return obj end
            local res = {}
            for k, v in pairs(obj) do res[copy(k)] = copy(v) end
            return res
        end

        function remove_nil_fields(tag, timestamp, record)
            return 2, timestamp, record
        end


        function add_host_metadata(tag, timestamp, record)
            new_record = record
            if isempty(new_record["host"]) then
                new_record["host"] = {}
            end
            local host = new_record["host"]
            if isempty(host["os"]) then
                host["os"] = {}
            end
            host["os"]["name"] = os.getenv("HOST_OS_NAME")
            host["os"]["type"] = os.getenv("HOST_OS_TYPE")
            host["os"]["family"] = os.getenv("HOST_OS_FAMILY")
            host["os"]["kernel"] = os.getenv("HOST_OS_KERNEL")
            host["os"]["full"] = os.getenv("HOST_OS_FULL")
            host["os"]["version"] = os.getenv("HOST_OS_VERSION")

            host["ip"] = os.getenv("HOST_IP")
            host["mac"] = os.getenv("HOST_MAC")
            if os.getenv("HOST_NAME") ~= nil then
                host["name"] = string.lower(os.getenv("HOST_NAME"))
            end
            if os.getenv("HOST_HOSTNAME") ~= nil then
                host["hostname"] = string.lower(os.getenv("HOST_HOSTNAME"))
            end
            host["domain"] = os.getenv("HOST_DOMAIN")
            host["architecture"] = os.getenv("HOST_ARCH")

            if not(isempty(host["ip"])) then
                host["ip"] = sdv2array(host["ip"])
            else
                host["ip"] = nil
            end

            if not(isempty(host["mac"])) then
                host["mac"] = sdv2array(host["mac"])
            else
                host["mac"] = nil
            end

            if not(isempty(host["name"])) then
                host["name"] = sdv2array(host["name"])
            else
                host["name"] = nil
            end

            if not(isempty(host["domain"])) then
                host["domain"] = sdv2array(host["domain"])
            else
                host["domain"] = nil
            end

            return 2, timestamp, new_record
        end
      outputs.conf: |
        [OUTPUT]
            Name  kinesis_streams
            Match *
            region ca-central-1
            stream ${AWS_KINESIS_STREAM}
            role_arn ${AWS_KINESIS_ROLE_ARN}
            Retry_Limit 3
      parsers.conf: |+
        @INCLUDE generic_json_parsers.conf
        @INCLUDE spar/parser/parsers.conf

      spar_filter_filters.conf: |

        [FILTER]
            Name lua
            Match spar.*
            script ${FLUENT_CONF_HOME}/timestamp.lua
            time_as_table True
            call append_timestamp

        [FILTER]
            Name modify
            Match spar.*
            Add event.kind event
            Add event.category web
            Add @metadata.keyAsPath true
      spar_input_inputs.conf: |
        [INPUT]
            Name tail
            Tag spar.log
            Buffer_Max_Size 1024k
            Parser spar.json
            Path /logs/postgres-api.log
            Path_Key log_file_path
            Offset_Key event_sequence
            DB /apps_data/agents/fluent-bit/fluent-bit-logs.db
            Read_from_Head True
            Refresh_Interval 15
      spar_parser_parsers.conf: |
        [PARSER]
            Name spar.json
            Match *
            Format json
            Time_Key @timestamp
            Time_Format %Y-%m-%dT%H:%M:%S.%LZ
      timestamp.lua: >
        function append_event_created(tag, timestamp, record)
            new_record = record
            new_record["event.created"] = (os.date("!%Y-%m-%dT%H:%M:%S", timestamp["sec"]) .. '.' .. math.floor(timestamp["nsec"] / 1000000) .. 'Z')
            return 2, timestamp, new_record
        end

        function append_timestamp(tag, timestamp, record)
          new_record = record
          new_record["@timestamp"] = (os.date("!%Y-%m-%dT%H:%M:%S", timestamp["sec"]) .. '.' .. math.floor(timestamp["nsec"] / 1000000) .. 'Z')
          return 2, timestamp, new_record
        end
parameters:
  - name: NAME
    description: Module name
    value: nr-spar-fluentbit-backend
  - name: ZONE
    description: Deployment zone, e.g. pr-### or prod
    required: true
  - name: REPO_NAME
    description: Application repository name
    displayName: Repository Name
    value: nr-spar-backend
  - name: NAMESPACE
    description: Target namespace reference (i.e. '9f0fbe-dev')
    displayName: Target Namespace
    required: true
  - name: LOGGING_HOST_NAME
    description: The hostname of our Fluentd service running further down the monitoring pipeline
    displayName: Fluentd host name
    required: false
  - name: AWS_KINESIS_STREAM
    description: AWS Kinesis Stream identifier
    displayName: AWS Kinesis Stream
    required: true
  - name: AWS_KINESIS_ROLE_ARN
    description: AWS OpenSearch/Kinesis Resource Name
    displayName: AWS Role ARN
    required: true
  - name: PROMOTE
    description: Image (namespace/name:tag) to promote/import
    value: bcgov/nr-spar-backend:prod-backend
